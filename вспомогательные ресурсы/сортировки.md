# Быстрая сортировка (quick sort)
* Принцип работы:
  1. Выбираем опопрный элемент (pivot, пивот), делаем разбиение (partition)
  2. Рекурсивно сортируем подмассив слева от опроного элемента и справа
* Принцип работы разбиения (функции partition)
  1. Возьмем в качестве pivot элемент, стоящий в середине массива
  2. В левой части ищем первый элемент, который больше чем pivot
  3. В правой части ищем второй элемент, который меньше чем pivot
  4. Меняем найденные два элемента местами
  5. Повторяем 2-5 пункт, пока слева не будут элементы меньшие pivot, а справа большие
* Псевдокод
Функция разбиения:
```
int partition(a: int[n], int l, int r)
     int v = a[(l + r) / 2]
     int i = l
     int j = r
     while (i ⩽ j) 
        while (a[i] < v)
           i++
        while (a[j] > v)
           j--
        if (i ⩾j) 
           break
        swap(a[i++], a[j--])
     return j
```  
Функция сортиовки:
```
  void quicksort(a: int[n], int l, int r)
     if l < r
        int q = partition(a, l, r)
        quicksort(a, l, q)
        quicksort(a, q + 1, r)
```
* Уважаемые и почти достоверные ресурсы:
  1. http://algolist.ru/sort/quick_sort.php
  2. https://habr.com/ru/company/otus/blog/524948/
# Сортировка слиянием (merge sort)
* Принцип работы:
  1. Делим массив на две равные части
  2. Повторяем п.1, пока задача не сведется до тривиальной (получен массив из 1 или 2-ух элементов)
  3. Сортируем подмассивы
  4. Сливаем подмассивы
* Принцип слияния
  1. Сравниваем элементы массивов (начиная с начала)
  2. Меньший из них записываем в результирующий
  3. Затем, в массиве у которого оказался меньший элемент, переходим к следующему элементу и сравниваем теперь его
  4. Повторяем пока не получим массив изначального размера
* Псевдокод
Функция слияния:
```
void merge(a: int[n], int l, int m, int r) 
    int n1 = m - l + 1,
        n2 = r - m,
        Left[n1], 
        Right[n2];
    for i = 0; i < n1; i++
        Left[i] = a[l + i]
    for i = 0; i < n2; i++
        Right[i] = a[m + 1 + i]
 
    int i = 0, j = 0, k = l
 
    while (i < n1 && j < n2) {
        if (Left[i] <= Right[j]) 
            a[k] = Left[i]
            i++
        else 
            a[k] = Right[j]
            j++
        
        k++
    }
    /* возможно тут чего-то не хватает */

```
Функция сортировки:
```
void sort(a: int[n], int l, int r)
    if (l < r)
        int mid = l + (r - l) / 2;
        sort(a, l, mid);
        sort(a, mid + 1, r);
        mergeSort(a, l, mid, r);
   

```
